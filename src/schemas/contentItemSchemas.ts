import { z } from "zod";
import { referenceObjectSchema } from "./referenceObjectSchema.js";

// Type definitions for recursive structures
type Reference = { id?: string; codename?: string; external_id?: string };

type RichTextComponent = {
  id: string;
  type: Reference;
  elements: VariantElementInComponent[] | null;
};

type VariantElementInComponent =
  | { element: Reference; value: Reference[] | null } // asset, linked items, multiple choice, taxonomy
  | {
      element: Reference;
      value: string | null;
      searchable_value: string | null;
    } // custom
  | {
      element: Reference;
      value: string | null;
      display_timezone: string | null;
    } // datetime
  | { element: Reference; value: number | null } // number
  | {
      element: Reference;
      value: string | null;
      components: RichTextComponent[] | null;
    } // rich text
  | { element: Reference; value: string | null } // text
  | {
      element: Reference;
      value: string | null;
      mode: "autogenerated" | "custom";
    }; // url slug

// Element schemas with descriptions based on Kontent.ai Management API documentation
const assetInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z
      .array(referenceObjectSchema)
      .nullable()
      .describe(
        "Array of Reference objects, each representing a single asset. Every asset can be referenced only once.",
      ),
  })
  .describe(
    "Asset element - references to assets (images, documents). Supports renditions for image-specific editions.",
  );

const customElementInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z
      .string()
      .max(200000)
      .nullable()
      .describe(
        "Custom-formatted data depending on the specific custom element implementation.",
      ),
    searchable_value: z
      .string()
      .max(200000)
      .nullable()
      .describe("Plain text for search functionality in content item lists."),
  })
  .describe(
    "Custom element - stores custom-formatted data with optional searchable plain text representation.",
  );

const dateTimeInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z.iso.datetime().nullable(),
    display_timezone: z
      .string()
      .nullable()
      .describe(
        "IANA time zone name affecting UI display without modifying stored value. Defaults to null (local time zone).",
      ),
  })
  .describe(
    "Date & time element - stores date and time values in UTC with optional display timezone.",
  );

const linkedItemsInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z
      .array(referenceObjectSchema)
      .nullable()
      .describe(
        "Array of Reference objects. Each reference represents a single content item (each item referenced only once).",
      ),
  })
  .describe(
    "Linked items element - references to other content items for modular content.",
  );

const multipleChoiceInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z
      .array(referenceObjectSchema)
      .nullable()
      .describe(
        "Array of Reference objects. Each reference represents one of the multiple choice options defined in content type.",
      ),
  })
  .describe(
    "Multiple choice element - references to selected choice options. Single-option mode requires exactly one reference.",
  );

const numberInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z.number().nullable().describe("Floating-point number."),
  })
  .describe("Number element - stores numeric floating-point values.");

const taxonomyInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z
      .array(referenceObjectSchema)
      .nullable()
      .describe(
        "Array of Reference objects. Each reference represents a taxonomy term (each term referenced only once).",
      ),
  })
  .describe(
    "Taxonomy element - references to taxonomy terms from a taxonomy group.",
  );

const textInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z.string().max(100000).nullable().describe("Plain text content."),
  })
  .describe("Text element - stores plain text content.");

const urlSlugInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    mode: z
      .enum(["autogenerated", "custom"])
      .describe(
        "'autogenerated' (system-generated based on dependent text element) or 'custom' (manual). Switches to custom when value is directly modified.",
      ),
    value: z.string().nullable().describe("URL-friendly slug value for SEO."),
  })
  .describe(
    "URL slug element - URL-friendly slug for SEO. Can be auto-generated from dependent text element or custom.",
  );

// Rich text component schema - uses lazy to handle circular reference
const richTextComponentSchema: z.ZodType<RichTextComponent> = z.lazy(() =>
  z
    .object({
      id: z
        .string()
        .describe(
          "Unique identifier of the component within the rich text element.",
        ),
      type: referenceObjectSchema.describe(
        "Reference to the content type defining the component structure.",
      ),
      elements: z
        .array(elementInComponentSchema)
        .nullable()
        .describe(
          "Array of element values within the component (supports up to 6 levels deep nesting).",
        ),
    })
    .describe(
      "Component embedded in rich text - a reusable content block defined by a content type.",
    ),
);

// Rich text element schema - references components which can contain any element type
const richTextInVariantElementSchema = z
  .object({
    element: referenceObjectSchema,
    value: z
      .string()
      .max(100000)
      .nullable()
      .describe("Valid HTML5 fragment. Defaults to '<p><br/></p>' if empty."),
    components: z
      .array(richTextComponentSchema)
      .nullable()
      .describe(
        "Array of nested component objects that can be embedded in the rich text content.",
      ),
  })
  .describe(
    "Rich text element - formatted HTML content that can include embedded assets, components, content items, and links.",
  );

// Union schema for elements within components
// Uses z.lazy() to handle circular reference with richTextComponentSchema
const elementInComponentSchema: z.ZodType<VariantElementInComponent> = z
  .lazy(() => languageVariantElementSchema)
  .describe(
    "Element value within a component - same structure as top-level variant elements.",
  );

// Top-level language variant element schema - discriminated by unique fields
export const languageVariantElementSchema = z.union([
  // Most specific schemas first (with unique distinguishing fields)
  urlSlugInVariantElementSchema, // has unique required 'mode' field
  richTextInVariantElementSchema, // has unique 'components' field
  dateTimeInVariantElementSchema, // has unique nullable 'display_timezone' field
  customElementInVariantElementSchema, // has unique 'searchable_value' field
  numberInVariantElementSchema, // has unique value type (number)

  // Medium specificity (array value types)
  assetInVariantElementSchema, // value: array of references
  linkedItemsInVariantElementSchema, // value: array of references
  multipleChoiceInVariantElementSchema, // value: array of references
  taxonomyInVariantElementSchema, // value: array of references

  // Least specific (basic string value, no unique fields)
  textInVariantElementSchema, // value: string, no distinguishing fields
]);
